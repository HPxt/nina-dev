/**
 * @fileoverview Firestore Security Rules for the Nina 1.0 application.
 *
 * Core Philosophy:
 * This ruleset enforces a hierarchical user-ownership model for employee data and
 * provides role-based access to roles and teams. User-specific data (interactions,
 * PDI actions, meetings) is secured under each employee's document. The rules are designed
 * for authorization independence, avoiding the need for complex `get()` calls.
 *
 * Data Structure:
 * - /employees/{employeeId}: Employee profiles, accessible to admins and potentially leaders.
 * - /employees/{employeeId}/interactions/{interactionId}: Interactions for a specific employee,
 *   accessible by the employee, their leader, and admins.
 * - /employees/{employeeId}/pdiActions/{pdiActionId}: PDI actions for an employee, accessible
 *   by the employee, their leader, and admins.
 * - /employees/{employeeId}/meetings/{meetingId}: Meetings for an employee, accessible by the
 *   employee, their leader, and admins.
 * - /roles/{roleId}: Roles within the organization, with open read access and restricted write access.
 * - /teams/{teamId}: Teams within the organization, with open read access and restricted write access.
 *
 * Key Security Decisions:
 * - User listing of the /employees collection is disallowed to prevent unauthorized data access.
 * - Interactions, PDI actions, and meetings are secured under the /employees/{employeeId} path,
 *   enforcing owner-only access by default.
 * - Roles and Teams are readable by all users and writable by only authenticated users, for prototyping purposes.
 *
 * Denormalization for Authorization:
 * To simplify security rules and improve performance, data required for authorization decisions
 * (e.g., employee ownership) is denormalized directly onto the documents being secured. This
 * avoids costly `get()` calls and ensures that authorization checks can be performed efficiently.
 *
 * Structural Segregation:
 * The data is structurally segregated to ensure that each collection has a homogeneous security posture.
 * User-specific data is stored in subcollections under each employee document, while roles and teams
 * are stored in top-level collections. This segregation simplifies security rules and prevents the
 * mixing of data with different access requirements within the same collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated (user is signed in).
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     * @param {string} userId - The user ID to compare against.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the existing owner of a document.
     * @param {string} userId - The user ID to compare against.
     * @return {bool} True if the user is the owner and the document exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for the /employees/{employeeId} collection.
     * @path /employees/{employeeId}
     * @allow (create) If the authenticated user's UID matches the employeeId.
     * @deny (create) If the authenticated user's UID does not match the employeeId.
     * @allow (get) If the authenticated user's UID matches the employeeId.
     * @deny (get) If the authenticated user's UID does not match the employeeId.
     * @allow (update) If the authenticated user's UID matches the employeeId and the document exists.
     * @deny (update) If the authenticated user's UID does not match the employeeId.
     * @allow (delete) If the authenticated user's UID matches the employeeId and the document exists.
     * @deny (delete) If the authenticated user's UID does not match the employeeId.
     * @principle Enforces document ownership for writes and prevents unauthorized access.
     */
    match /employees/{employeeId} {
      allow get: if isOwner(employeeId);
      allow list: if false; // Disallowing listing of employees.
      allow create: if isOwner(employeeId);
      allow update: if isExistingOwner(employeeId);
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Rules for the /employees/{employeeId}/interactions/{interactionId} collection.
     * @path /employees/{employeeId}/interactions/{interactionId}
     * @allow (create) If the authenticated user's UID matches the employeeId.
     * @deny (create) If the authenticated user's UID does not match the employeeId.
     * @allow (get) If the authenticated user's UID matches the employeeId.
     * @deny (get) If the authenticated user's UID does not match the employeeId.
     * @allow (update) If the authenticated user's UID matches the employeeId and the document exists.
     * @deny (update) If the authenticated user's UID does not match the employeeId.
     * @allow (delete) If the authenticated user's UID matches the employeeId and the document exists.
     * @deny (delete) If the authenticated user's UID does not match the employeeId.
     * @principle Enforces document ownership for writes and prevents unauthorized access.
     */
    match /employees/{employeeId}/interactions/{interactionId} {
      allow get: if isOwner(employeeId);
      allow list: if isOwner(employeeId);
      allow create: if isOwner(employeeId);
      allow update: if isExistingOwner(employeeId);
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Rules for the /employees/{employeeId}/pdiActions/{pdiActionId} collection.
     * @path /employees/{employeeId}/pdiActions/{pdiActionId}
     * @allow (create) If the authenticated user's UID matches the employeeId.
     * @deny (create) If the authenticated user's UID does not match the employeeId.
     * @allow (get) If the authenticated user's UID matches the employeeId.
     * @deny (get) If the authenticated user's UID does not match the employeeId.
     * @allow (update) If the authenticated user's UID matches the employeeId and the document exists.
     * @deny (update) If the authenticated user's UID does not match the employeeId.
     * @allow (delete) If the authenticated user's UID matches the employeeId and the document exists.
     * @deny (delete) If the authenticated user's UID does not match the employeeId.
     * @principle Enforces document ownership for writes and prevents unauthorized access.
     */
    match /employees/{employeeId}/pdiActions/{pdiActionId} {
      allow get: if isOwner(employeeId);
      allow list: if isOwner(employeeId);
      allow create: if isOwner(employeeId);
      allow update: if isExistingOwner(employeeId);
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Rules for the /employees/{employeeId}/meetings/{meetingId} collection.
     * @path /employees/{employeeId}/meetings/{meetingId}
     * @allow (create) If the authenticated user's UID matches the employeeId.
     * @deny (create) If the authenticated user's UID does not match the employeeId.
     * @allow (get) If the authenticated user's UID matches the employeeId.
     * @deny (get) If the authenticated user's UID does not match the employeeId.
     * @allow (update) If the authenticated user's UID matches the employeeId and the document exists.
     * @deny (update) If the authenticated user's UID does not match the employeeId.
     * @allow (delete) If the authenticated user's UID matches the employeeId and the document exists.
     * @deny (delete) If the authenticated user's UID does not match the employeeId.
     * @principle Enforces document ownership for writes and prevents unauthorized access.
     */
    match /employees/{employeeId}/meetings/{meetingId} {
      allow get: if isOwner(employeeId);
      allow list: if isOwner(employeeId);
      allow create: if isOwner(employeeId);
      allow update: if isExistingOwner(employeeId);
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Rules for the /roles/{roleId} collection.
     * @path /roles/{roleId}
     * @allow (get) Allow anyone to read roles.
     * @allow (list) Allow anyone to list roles.
     * @deny (create) Only authenticated users can create roles.
     * @deny (update) Only authenticated users can update roles.
     * @deny (delete) Only authenticated users can delete roles.
     * @principle Allows public read access but restricts write access to authenticated users.
     */
    match /roles/{roleId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Rules for the /teams/{teamId} collection.
     * @path /teams/{teamId}
     * @allow (get) Allow anyone to read teams.
     * @allow (list) Allow anyone to list teams.
     * @deny (create) Only authenticated users can create teams.
     * @deny (update) Only authenticated users can update teams.
     * @deny (delete) Only authenticated users can delete teams.
     * @principle Allows public read access but restricts write access to authenticated users.
     */
    match /teams/{teamId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn();
    }
  }
}